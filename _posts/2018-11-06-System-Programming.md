---
layout: post
title:  "System Programming"
date:   2018-11-06 08:00
categories: study
---
# 책 소개
>  [Computer Systems. A Programmer's Perspective] - Bryant, O'Hallaron (김형신 옮김) (제3판)

# [1장] 컴퓨터 시스템으로의 여행

## <1.1> 정보는 비트와 컨텍스트로 이루어진다.
* 비트 : 모든 시스템 내의 정보( 디스크 파일, 메모리상의 프로그램, 네트워크 통해 전송되는 데이터) 는 비트들로 표시 된다.

* 컨텍스트 : 이 비트들을 어떻게 해석할 지 라고 생각한다. 동일한 일련의 비트(or 바이트) 가 다른 컨텍스트에서 다른 기계어 명령을 의미할 수 있다. 

* 일련의 2진수(비트)와 그 비트를 어떻게 해석할지(컨텍스트) 로 정보가 이루어져있다.

## <1.2> 프로그램은 다른프로그램에 의해 다른 형태로 번역된다.
* 우리가 작성한 텍스트 파일은 다른 프로그램( 전처리기, 컴파일러, 어셈블러, 링커) 등에 의해서 실행 가능한 파일로 번역 된다.

* C 프로그램 번역 과정 (변화 과정, 컴파일 과정)
    1. Source Program (or source file) = hello.c
    2. Modified Source Program = hello.i
    3. Assembly Program = hello.s
    4. Relocatable Object Programs = hello.o
    5. Executable Object Programs = hello


* 번역하는(변화 시켜주는) 프로그램
    1. 전처리기(pre-processor)
        - hello.c -> hello.i
        - #include <stdio.h> 같이 # 으로 시작하는 directive 에 따라 수정한다.
        - 전처리기에게 시스템 헤더파일인 stdio.h 를 프로그램 문장에 직접 삽입하라고 지시
    2. 컴파일러(compiler)
        - hello.i -> hello.s
        - 어셈블리어로 바꿔준다.
    3. 어셈블러(assembler)
        - hello.s -> hello.o
        - 어셈블리어를 기계어로 바꿔준다.
    4. 링커(Linker)
        - hello.o -> 실행가능한 hello 프로그램
        - hello.o + printf.o (hello.c 안에 쓰인 printf 함수로 인해 link 된다.) 

## <1.3> 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.
* 프로그램 성능 최적화 가능
* 링크 에러 이해 가능
* 보안 약점 피하기 가능

## <1.4> 프로세서는 메모리에 저장된 instruction 을 읽고 해석한다.
* 하드웨어 조직 중 메모리에 저장된 instruction 을 프로세서(CPU)가 해석해서 실행 
* 시스템의 하드웨어 조직

    * <img src="/resource/img/systemprogramming(1).jpg" width="400px" height="300px">
    * 버스
        - 시스템 내를 관통하는 전기적 배선군
        - 컴포넌트들 간에 바이트 정보들을 전달
        - 워드라고 하는 고정 크기의 바이트 단위로 데이타를 전송 ( 32 bit 운영 체제는 1 word = 32bit, 64 bit 운영 체제는 1 word = 64 bit)
    * 입출력 장치 
        - 시스템과 외부 세계와의 연결을 담당
    * 메인 메모리 (RAM)
        - 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치
    * 프로세서 (CPU)
        - 메인 메모리에 저장된 인스트럭션(일련의 bit)들을 해독하는 엔진 

* hello 프로그램의 실행
    1. 사용자가 shell 프로그램(프로그램을 실행시킬 수 있는)을 통해 명령어 hello 를 **입력** 한다. ( 입출력 장치 )
    2. **디스크(저장 장치)**에 있는 프로그램 인스트럭션과 데이터를 복사해 **메인 메모리(RAM)**로 로딩 (직접 메모리 접근을 통해 (6장) 디스크에서 메인 메모리로 직접 이동, 적재)
    3. **프로세서**는 **메인 메모리**에 있는 인스트럭션을 실행

* 3장에서 기계어 코드를 배우면서 기계어 인스트럭션 집합 구조에 의한 추상화를 고려
* 4장에서 프로세서들이 실제로 어떻게 구현되어 있는지 자세히.
* 5장에서 최신 프로세서들이 어떻게 기계어 프로그램의 성능을 예측하고 최적화할 수 있도록 해주는 방법의 모델링

## <1.5> 캐시가 중요하다.
* <img src="/resource/img/systemprogramming(2).jpg" width="400px" height="300px">
* 시스템에서 정보를 한 곳에서 다른 곳으로 이동시키는 일에 많은 시간을 보낸다.
* 큰 저장장치는 보다 작은 저장장치보다 느린 속도를 갖는다.
* 프로세서와 메인 메모리 사이에 격차를 줄이기 위해 시스템 설계자는 보다 작고 빠른 캬시 메모리라고 부르는 저장장치를 고안했다.
* 프로세서가 단기간에 필요로 할 가능성이 높은 정보를 임시로 저장할 목적으로 사용한다.
* 캐시 메모리를 이해하는 응용 프로그래머는 캐시를 활용하여 자신의 프로그램 성능을 10배 이상 개선할 수 있다. 6장에서 자세히.

## <1.6> 저장장치들은 계층 구조를 이룬다.
* <img src="/resource/img/systemprogramming(5).jpg" width="400px" height="300px">
* 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할을 한다.
* 6장에서 자세히

## <1.7> 운영체제는 하드웨어를 관리한다.
* 응용 프로그램이 하드웨어(Processor, Main memory, I/O devices)를 제어하려면 언제나 운영체제를 통해서 해야한다.

* 프로세스
    * <img src="/resource/img/systemprogramming(3).jpg" width="300px" height="100px">
    * 프로세스 = 실행 중인 프로그램에 대한 운영체제의 추상화. 그러니까 운영체제는 프로세스로 프로그램을 인식한다. 
    * 프로세스 = 프로세서 + 메인 메모리 + 입출력 장치 (이해 : 클래스 = 필드 + 메소드)
    * 프로세서와 메인 메모리 입출력 장치를 쓰는 프로세스가 여러 개가 동시에(concurrently) 실행 될 수 있다.
    * 한 프로세스의 인스트럭션과 다른 프로세스의 인스트럭션이 섞인다. 
    * 한 프로세서(CPU) 가 각 프로세스 들의 인스트럭션을 바꿔가며 실행해서 동시에 실행되는 것처럼 보이게 한다.
    * 커널이란 운영체제 내의 코드와 자료구조가 현재 컨텍스트를 전환 해준다.
    * 컨텍스트는 문맥. 그냥 현재 어떤 프로세스의 어떤 인스트럭션이 실행되는지 정도로 이해했다.

* 쓰레드
    * 12장 에서 자세히

* 가상 메모리
    * 9 장 에서 자세히

* 파일
    * 그저 연속된 바이트들
    * 디스크,키보드,디스플레이,네트워크 까지 포함되는 모든 입출력장치는 파일로 모델링
    * 시스템의 모든 입출력은 시스템 콜들을 이용하여 파일을 읽고 쓰는 형태로 이루어진다.

## <1.8> 시스템은 네트워크를  사용하여 다른 시스템과 통신한다.
* <img src="/resource/img/systemprogramming(4).jpg" width="400px" height="300px">
* 또 다른 입출력 장치이다.
* 키보드로 입력 받듯이 다른 컴퓨터에서 네트워크를 통해 데이터를 읽어서 메인 메모리에 복사.
* 11장 에서 자세히

## <1.9> 중요한 주제들 
* Amdahl의 법칙

* 동시성과 병렬성
    * 동시성(concurrency) : 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념
    * 병렬성(parallelism) : 동시성을 사용해 시스템을 보다 빠르게 동작하도록 하는 것
    * 동시성이라는 특징을 이용해 병렬적으로 만든다 정도로 이해.
    * 쓰레드 수준의 동시성
        * 한 개의 프로세스 내에서 실행되는 다수의 제어흐름을 가질 수도 있다 = 한 개의 물줄기를 여러 물줄기로 나눠서 흐르게 할 수 있다.
        * 단일 프로세서 시스템 : 하나의 프로세서가 여러 프로세스를 동시에 실행시키는 것처럼 보이게 빠르게 전환시킴
        * 멀티 프로세서 시스템 : 한 운영체제 커널 하에 여러 개의 프로세서를 가지고 여러 개의 프로세스를 실행시키는 시스템
        * 하이퍼 쓰레딩 : 하나의 CPU 가 하나의 프로세스 내에 여러 개의 제어 흐름을 실행 할 수 있게 해주는 기술
        * 단일 프로세서 시스템은 하나의 CPU 가 여러 프로세스를 실행 시키게 // 하이퍼 쓰레딩은 하나의 CPU 가 하나의 프로세스 내에 여러 개의 제어 흐름을 실행 할 수 있게
        * 12장 에서 자세히
    * 인스트럭션 수준 병렬성
        * 프로세서는 여러가지 교묘한 기법을 이용해서 한 번에 100개의 인스트럭션까지 처리할 수 있다.
        * 4장 에서 자세히 (파이프 라이닝)
        * 슈퍼스케일러 : 사이클 당 한 개의 인스트럭션을 실행할 수 있는 프로세서.
        * 5장 에서 자세히
    * 싱글 인스트럭션, 다중 데이터 병렬성(SIMD)
        * 최신 프로세서들은 최하위 수준에서 싱글 인스트럭션, 다중 데이터(SIMD) 병렬성이라는 모드로 한 개의 인스트럭션이 병렬로 다수의 연산을 수행할 수 있는 특수 하드웨어를 가지고 있다.
    * 정리 하자면 병렬성을 통해 컴퓨터가 빨라지고 있다.

* 추상화의 중요성
    * 프로그래머가 그 내부의 동작을 고려하지 않으면서 코드를 사용할 수 있게 해준다 (ex: 우리가 화면에 기계어로 어떤 인스트럭션 써서 어떻게 띄우는지(내부 동작) 모르지만 printf 쓰면(코드) 화면에 띄울 수 있다.)
    * 자바 코드 - 클래스1 + 클래스2 ... 
    * C - 함수 프로토타입으로 추상화
    * 시스템 - 운영체제 + 프로세서 + 메인메모리 + I/O devices
    * 프로세스 - 프로세서 + 메인 메모리 + I/O devices
    * 인스트럭션 집합 구조 -> 기계어 코드 프로그램이 마치 한 번에 하나의 인스트럭션을 실행하는 것처럼 보이게 ( 사실은 동시에 인스트럭션을 병렬로 여러개 수행)
    * 파일 : 입출력 장치의 추상화
    * 가상메모리 : 프로그램 메모리의 추상화 (프로그램 메모리는 실제로는 다르지만 간단하게 사용할 수 있게 가상 메모리란 것을 만들어 쉽게 쓰게 함)

# [2장] 정보의 표현과 처리
## <2.1> 정보의 저장
## <2.2> 정수의 표시
## <2.3> 정수의 산술연산
## <2.4> 부동 소수점

# [3장] 프로그램의 기계수준 표현
## <3.1> 역사적 관점
## <3.2> 프로그램의 인코딩
## <3.3> 데이터의 형식
## <3.4> 정보 접근하기
## <3.5> 산술 연산과 논리 연산
## <3.6> 제어문
## <3.7> 프로시저
## <3.8> 배열의 할당과 접근
## <3.9> 이기종 자료구조
## <3.10> 기계 수준 프로그램에서 제어와 데이터의 결합
## <3.11> 부동소수점 코드

# [4장] 프로세서 구조
## <4.1> Y86-64 인스트럭션 집합
## <4.2> 논리 설계와 하드웨어 제어 언어 HCL
## <4.3> 순차적 Y86-64 구현
## <4.4> 파이프라이닝의 일반 원리
## <4.5> 파이프라인형 Y86-64 의 구현

# [5장] 프로그램 성능 최적화 하기
## <5.1> 최적화 컴파일러 능력과 한계
## <5.2> 프로그램 성능의 표현
## <5.3> 프로그램 예제
## <5.4> 루프 비효율성 제거하기
## <5.5> 프로시저 호출 줄이기
## <5.6> 불필요한 메모리 참조의 제거
## <5.7> 최신 프로세서 이해하기
## <5.8> 루프 풀기
## <5.9> 병렬성 높이기
## <5.10> 연결코드 최적화 결과의 요약
## <5.11> 일부 제한 요인들
## <5.12> 메모리 성능의 이해
## <5.13> 실제 상황: 성능개선 기술
## <5.14> 성능 병목지점의 식별과 제거

# [6장] 메모리 계층구조
## <6.1>
## <6.2>
## <6.3>
## <6.4>
## <6.5>
## <6.6>
## <6.7>

# [7장] 링커
## <7.1>
## <7.2>
## <7.3>
## <7.4>
## <7.5>
## <7.6>
## <7.7>
## <7.8>
## <7.9>
## <7.10>
## <7.11>
## <7.12>
## <7.13>
## <7.14>

# [8장] 예외적인 제어흐름
## <8.1>
## <8.2>
## <8.3>
## <8.4>
## <8.5>
## <8.6>
## <8.7>

# [9장] 가상 메모리
## <9.1>
## <9.2>
## <9.3>
## <9.4>
## <9.5>
## <9.6>
## <9.7>
## <9.8>
## <9.9>
## <9.10>
## <9.11>

# [10장] 시스템 수준 입출력
## <10.1>
## <10.2>
## <10.3>
## <10.4>
## <10.5>
## <10.6>
## <10.7>
## <10.8>
## <10.9>
## <10.10>
## <10.11>

# [11장] 네트워크 프로그래밍
## <11.1>
## <11.2>
## <11.3>
## <11.4>
## <11.5>
## <11.6>

# [12장] 동시성 프로그래밍
## <12.1>
## <12.2>
## <12.3>
## <12.4>
## <12.5>
## <12.6>
## <12.7>