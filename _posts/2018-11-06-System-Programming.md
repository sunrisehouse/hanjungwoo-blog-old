---
layout: post
title:  "System Programming"
date:   2018-11-06 08:00
categories: system programming, study
comments: true
---
# 책 소개
>  [Computer Systems. A Programmer's Perspective] - Bryant, O'Hallaron (김형신 옮김) (제3판)
> 

# [1장] 컴퓨터 시스템으로의 여행
 
## <1.1> 정보는 비트와 컨텍스트로 이루어진다.
    * 비트 : 모든 시스템 내의 정보( 디스크 파일, 메모리상의 프로그램, 네트워크 통해 전송되는 데이터) 는 비트들로 표시 된다.
    * 컨텍스트 : 이 비트들을 어떻게 해석할 지 라고 생각한다. 동일한 일련의 비트(or 바이트) 가 다른 컨텍스트에서 다른 기계어 명령을 의미할 수 있다. 
    * 일련의 2진수(비트)와 그 비트를 어떻게 해석할지(컨텍스트) 로 정보가 이루어져있다.
## <1.2> 프로그램은 다른프로그램에 의해 다른 형태로 번역된다.
    * 우리가 작성한 텍스트 파일은 다른 프로그램( 전처리기, 컴파일러, 어셈블러, 링커) 등에 의해서 실행 가능한 파일로 번역 된다.
    * C 프로그램 번역 과정 (변화 과정, 컴파일 과정)
        1. Source Program (or source file) = hello.c
        2. Modified Source Program = hello.i
        3. Assembly Program = hello.s
        4. Relocatable Object Programs = hello.o
        5. Executable Object Programs = hello
    * 번역하는(변화 시켜주는) 프로그램
        1. 전처리기(pre-processor)
            - hello.c -> hello.i
            - #include <stdio.h> 같이 # 으로 시작하는 directive 에 따라 수정한다.
            - 전처리기에게 시스템 헤더파일인 stdio.h 를 프로그램 문장에 직접 삽입하라고 지시
        2. 컴파일러(compiler)
            - hello.i -> hello.s
            - 어셈블리어로 바꿔준다.
        3. 어셈블러(assembler)
            - hello.s -> hello.o
            - 어셈블리어를 기계어로 바꿔준다.
        4. 링커(Linker)
            - hello.o -> 실행가능한 hello 프로그램
            - hello.o + printf.o (hello.c 안에 쓰인 printf 함수로 인해 link 된다.) 
## <1.3> 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.
    * 프로그램 성능 최적화 가능
    * 링크 에러 이해 가능
    * 보안 약점 피하기 가능
## <1.4> 프로세서는 메모리에 저장된 instruction 을 읽고 해석한다.
## <1.5> 캐시가 중요하다.
## <1.6> 저장장치들은 계층 구조를 이룬다.
## <1.7> 운영체제는 하드웨어를 관리한다.
## <1.8> 시스템은 네트워크를  사용하여 다른 시스템과 통신한다.
## <1.9> 중요한 주제들 

# [2장] 정보의 표현과 처리
## <2.1> 정보의 저장
## <2.2> 정수의 표시
## <2.3> 정수의 산술연산
## <2.4> 부동 소수점

# [3장] 프로그램의 기계수준 표현
## <3.1> 역사적 관점
## <3.2> 프로그램의 인코딩
## <3.3> 데이터의 형식
## <3.4> 정보 접근하기
## <3.5> 산술 연산과 논리 연산
## <3.6> 제어문
## <3.7> 프로시저
## <3.8> 배열의 할당과 접근
## <3.9> 이기종 자료구조
## <3.10> 기계 수준 프로그램에서 제어와 데이터의 결합
## <3.11> 부동소수점 코드

# [4장] 프로세서 구조
## <4.1> Y86-64 인스트럭션 집합
## <4.2> 논리 설계와 하드웨어 제어 언어 HCL
## <4.3> 순차적 Y86-64 구현
## <4.4> 파이프라이닝의 일반 원리
## <4.5> 파이프라인형 Y86-64 의 구현

# [5장] 프로그램 성능 최적화 하기
## <5.1> 최적화 컴파일러 능력과 한계
## <5.2> 프로그램 성능의 표현
## <5.3> 프로그램 예제
## <5.4> 루프 비효율성 제거하기
## <5.5> 프로시저 호출 줄이기
## <5.6> 불필요한 메모리 참조의 제거
## <5.7> 최신 프로세서 이해하기
## <5.8> 루프 풀기
## <5.9> 병렬성 높이기
## <5.10> 연결코드 최적화 결과의 요약
## <5.11> 일부 제한 요인들
## <5.12> 메모리 성능의 이해
## <5.13> 실제 상황: 성능개선 기술
## <5.14> 성능 병목지점의 식별과 제거

# [6장] 메모리 계층구조
## <6.1>
## <6.2>
## <6.3>
## <6.4>
## <6.5>
## <6.6>
## <6.7>

# [7장] 링커
## <7.1>
## <7.2>
## <7.3>
## <7.4>
## <7.5>
## <7.6>
## <7.7>
## <7.8>
## <7.9>
## <7.10>
## <7.11>
## <7.12>
## <7.13>
## <7.14>

# [8장] 예외적인 제어흐름
## <8.1>
## <8.2>
## <8.3>
## <8.4>
## <8.5>
## <8.6>
## <8.7>

# [9장] 가상 메모리
## <9.1>
## <9.2>
## <9.3>
## <9.4>
## <9.5>
## <9.6>
## <9.7>
## <9.8>
## <9.9>
## <9.10>
## <9.11>

# [10장] 시스템 수준 입출력
## <10.1>
## <10.2>
## <10.3>
## <10.4>
## <10.5>
## <10.6>
## <10.7>
## <10.8>
## <10.9>
## <10.10>
## <10.11>

# [11장] 네트워크 프로그래밍
## <11.1>
## <11.2>
## <11.3>
## <11.4>
## <11.5>
## <11.6>

# [12장] 동시성 프로그래밍
## <12.1>
## <12.2>
## <12.3>
## <12.4>
## <12.5>
## <12.6>
## <12.7>