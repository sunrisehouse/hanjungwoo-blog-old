---
layout: post
title:  "System Programming Chapter 05"
date:   2018-11-06 08:00
---

# [5장] 프로그램 성능 최적화 하기
* 효율적인 프로그램 작성하는 방법
    - 최적화 하기
        1. 적절한 알고리즘 과 자료구조 사용하기.
        2. 컴파일러가 효율적으로 최적화 하도록 코드 작성하기. -> 최적화 장애물들 제거해 컴파일러를 도아서 쉽게 최적화될 수 있는 코드 작성하기.
## <5.1> 최적화 컴파일러 능력과 한계
* 안전한 최적화
    - 최적화 된 것과 안 된 것이 정확히 동일한(C 언어 표준이 제공하는 보장의 한계까지 동일한) 동작을 가져야 한다는 것을 의미.
* 최적화 장애물 1 - 메모리 연결 (memory aliasing)
    - 결론 : 안전한 최적화 위해서는 **메모리가 연결**될 수 있다고 가정해야 한다.
    - ex) 안전하지 않은 프로그램 변환
        * ``` c
            void twiddle1(long *xp, long*yp){
                *xp += *yp;
                *xp += *yp;
            }    
            void twiddle2(long *xp, long*yp){
                *xp += 2 * *yp;
            }
        * 보기엔 동일한 동작 ( x 에다가 y의 2배를 더하는 함수)
        * twiddle2 가 더 효율적 ( 메모리 참조를 3번만 하기 때문. twiddle1은 6번)
        * 그럼 twiddle1 은 컴파일 하게 되면 twiddle2 처럼 더 효율적인 코드 생성할까?? -> 아니다.
        * twiddle2 와 twiddle1 은 다른 결과가 나올 수가 있다 -> xp 와 yp 가 같을 때( 메모리 연결, 주소값이 같을 때, memory aliasing)

* 최적화 장애물 2 - 함수 호출
    - ex) 안전하지 않은 프로그램 변환
        * ``` c
            long f();

            long func1(){
                return f()+f()+f()+f();
            }

            long func2(){
                return 4*f();
            }
        * 둘 다 같은 결과를 계산하는 것 처럼 보인다.
        * 하지만 func2가 f 를 한 번만 호출 하므로 컴파일러에서 최적화시 func1이 func2 스타일로 코드를 생성하려 할 수 있다.
        * ``` c
            long coungter = 0;
            long f(){
                return counter++;
            }
        * 하지만 만약 f 가 이런 함수라면 부과 효과(side effenct) 를 갖는다.
## <5.2> 프로그램 성능의 표현
* CPE - 요소당 측정 사이클(metric cycle) : 반복적인 프로그램의 루프 성능을 자세히 이해 가능.
* ``` c
    void psum1(float a[],float p[], long n){
        long i;
        p[0] = a[0];
        for(i=1;i<n;i++){
            p[i] = p[i-1] + a[i];
        }
    }
    void psum2(float a[],float p[], long n){
        long i;
        p[0] = a[0];
        for(i=1;i<n-1;i+=2){
            float mid_val = p[i-1]+a[i];
            p[i] = mid_val;
            p[i+1] = mid_val + a[i+1]
        }
        if(i<n){
            p[i] = p[i-1] + a[i];
        }
    }
* psum1, psum2 는 모두 길이 n을 갖는 벡터의 접두합을 계산하는 함수.
    - psum1 : 반복실행마다 한 원소 계산
        - 실행시간 : 368 + 9.0n (클럭 수)
        - CPE : 9.0
    - psum2 : 반복실행마다 두 원소를 계산하기 위해 **루프 풀기(loop unrolling)** 기법 사용
        - 실행시간 : 368 + 6.0n (클럭 수)
        - CPE : 6.0
    - 더 적은 반복을 하는 psum2 가 더 빠르다.
    
## <5.3> 프로그램 예제
## <5.4> 루프 비효율성 제거하기
## <5.5> 프로시저 호출 줄이기
## <5.6> 불필요한 메모리 참조의 제거
## <5.7> 최신 프로세서 이해하기
## <5.8> 루프 풀기
## <5.9> 병렬성 높이기
## <5.10> 연결코드 최적화 결과의 요약
## <5.11> 일부 제한 요인들
## <5.12> 메모리 성능의 이해
## <5.13> 실제 상황: 성능개선 기술
## <5.14> 성능 병목지점의 식별과 제거